package main

import (
	"bufio"
	"bytes"
	"crypto"
	"crypto/ecdsa"
	"crypto/elliptic"
	"crypto/rand"
	"crypto/tls"
	"crypto/x509"
	"encoding/pem"
	"flag"
	"log"
	"math/big"
	"os"
	"os/signal"
	"runtime"
	"time"
)

func main() {
	listenAddr := flag.String(
		"a",
		"127.0.0.1:8443",
		"Listen address")
	privateKey := flag.String(
		"k",
		"",
		"Private key file path (autogenerated if not specified)")
	showPrivateKey := flag.Bool(
		"showprivatekey",
		false,
		"Write the autogenerated private key PEM to stderr")
	certificateChain := flag.String(
		"c",
		"",
		"Certificate chain file path (autogenerated if not specified)\nSee https://pkg.go.dev/crypto/tls#LoadX509KeyPair for details")
	getFromStdin := flag.Bool(
		"i",
		false,
		"Get the private key and certificate chain from stdin")

	flag.Parse()

	var tlsCert tls.Certificate
	var err error
	if len(*certificateChain) > 0 || len(*privateKey) > 0 {
		tlsCert, err = tls.LoadX509KeyPair(*certificateChain, *privateKey)
		if err != nil {
			log.Fatalf("failed to load x509 certificate chain or private key - %s", err)
		}

		log.Println("loaded private key and certificate chain from disk")
	} else if *getFromStdin {
		keyboardCombo := "control+d"
		if runtime.GOOS == "windows" {
			keyboardCombo = "control+c"
		}
		log.Printf("press %s after entering private key PEM and certificate chain PEM", keyboardCombo)

		tlsCert, err = tlsCertFromStdin()
		if err != nil {
			log.Fatalf("failed to load x509 certificate chain or private key - %s", err)
		}

		log.Println("loaded private key and certificate chain from stdin")
	} else {
		logger := log.New(log.Writer(), log.Prefix(), log.Flags())
		expiresAt := time.Now().Add(24*time.Hour)
		caTemp := x509TemplateWithExpirationOrFail(expiresAt, logger)
		caTemp.Subject.Organization = []string{"cool"}
		ca := newCertOrFail(caTemp, nil, logger)

		interTemp := x509TemplateWithExpirationOrFail(expiresAt, logger)
		interTemp.Subject.Organization = []string{"cool"}
		intermediate := newCertOrFail(interTemp, ca, logger)

		expDomains := []string{"nasa.notcool.com", "blah.notcool.com"}
		endEntityTemp := x509TemplateWithExpirationOrFail(expiresAt, logger)
		endEntityTemp.Subject.Organization = []string{"not-cool"}
		endEntityTemp.DNSNames = expDomains
		endEntity := newCertOrFail(endEntityTemp, intermediate, logger)

		certChain := append(pem.EncodeToMemory(endEntity.CertBlock),
			pem.EncodeToMemory(intermediate.CertBlock)...)

		privateKeyPEM := pem.EncodeToMemory(endEntity.PrivateKeyBlock)
		tlsCert, err = tls.X509KeyPair(certChain, privateKeyPEM)
		if err != nil {
			log.Fatalf("failed to create testing x509 certificate chain or private key - %s", err)
		}

		log.Println("autogenerated a private key and certificate")
		log.Printf("certificate chain:\n%s", certChain)
		if *showPrivateKey {
			log.Printf("private key:\n%s", privateKeyPEM)
		}
	}

	l, err := tls.Listen("tcp", *listenAddr, &tls.Config{
		Certificates: []tls.Certificate{tlsCert},
	})
	if err != nil {
		log.Fatalf("failed to start tls listener - %s", err)
	}

	log.Printf("listening for connections at %s...", *listenAddr)

	for {
		c, err := l.Accept()
		if err != nil {
			log.Printf("[%s] failed to accept tls connection for this client - %s",
				c.RemoteAddr(), err)
			continue
		}

		switch asserted := c.(type) {
		case *tls.Conn:
			err = asserted.Handshake()
			if err != nil {
				log.Printf("[%s] tls handshake failed - %s", c.RemoteAddr(), err)
			} else {
				log.Printf("[%s] tls handshake successful", c.RemoteAddr())
			}
		default:
			log.Printf("connection is not of type *tls.Conn")
		}

		c.Close()
	}
}

func tlsCertFromStdin() (tls.Certificate, error) {
	if runtime.GOOS == "windows" {
		// Winbloze.
		done := make(chan os.Signal, 1)
		signal.Notify(done, os.Interrupt)
		go func() {
			<-done
			os.Stdin.Close()
		}()
		defer signal.Stop(done)
	}

	var privateKeyPEM []byte
	var certChainPEM []byte
	onKey := false
	onCert := false
	scanner := bufio.NewScanner(os.Stdin)
	for scanner.Scan() {
		if bytes.Contains(scanner.Bytes(), []byte("KEY")) {
			onKey = true
			onCert = false
		} else if bytes.Contains(scanner.Bytes(), []byte("CERTIFICATE")) {
			onCert = true
			onKey = false
		} else if len(scanner.Bytes()) == 0 {
			continue
		}

		if onCert {
			certChainPEM = append(certChainPEM, scanner.Bytes()...)
			certChainPEM = append(certChainPEM, '\n')
		} else if onKey {
			privateKeyPEM = append(privateKeyPEM, scanner.Bytes()...)
			privateKeyPEM = append(privateKeyPEM, '\n')
		}
	}

	return tls.X509KeyPair(certChainPEM, privateKeyPEM)
}

// newCertOrFail creates a new X.509 certificate based upon the provided
// template certificate. See 'x509.CreateCertificate()' for details about
// this functionality. If a non-nil parent certAndKeyPair are provided,
// then the new certificate will be signed by that parent.
func newCertOrFail(template *x509.Certificate, optionalParent *certAndKeyPair, logger *log.Logger) *certAndKeyPair {
	temp := *template
	templateCopy := &temp

	// ECDSA for P E R F O R M A N C E!
	newCertKey, err := ecdsa.GenerateKey(elliptic.P384(), rand.Reader)
	if err != nil {
		logger.Fatalf("failed to generate private key - %s", err.Error())
	}

	var certRaw []byte
	if optionalParent == nil {
		templateCopy.IsCA = true
		templateCopy.BasicConstraintsValid = true
		templateCopy.KeyUsage |= x509.KeyUsageCertSign
		certRaw, err = x509.CreateCertificate(
			rand.Reader,
			templateCopy,
			templateCopy,
			&newCertKey.PublicKey,
			newCertKey)
	} else {
		certRaw, err = x509.CreateCertificate(
			rand.Reader,
			templateCopy,
			optionalParent.X509Cert,
			&newCertKey.PublicKey,
			optionalParent.PrivateKey)
	}
	if err != nil {
		logger.Fatalf("failed to generate certificate - %s", err.Error())
	}

	// This is unfortunately necessary to get all of the
	// fields set by 'x509.CreateCertificate()'. For example,
	// we do note set Certificate.PublicKey in the "template"
	// certificate given to the 'x509.CreateCertificate()'
	// function because... well, the function takes care of
	// that for us. However, upstream code that needs the
	// Certificate struct also needs the public key to be set.
	// Since there does not appear to be a method to generate
	// both the ASN.1 data, and simultaneously retrieve the
	// parsed Certificate struct - this is what we will do.
	cert, err := x509.ParseCertificate(certRaw)
	if err != nil {
		logger.Fatalf("failed to parse certificate back from bytes - %s", err.Error())
	}

	privateKeyRaw, err := x509.MarshalECPrivateKey(newCertKey)
	if err != nil {
		logger.Fatalf("failed to marshal ec private key to bytes - %s", err.Error())
	}

	return &certAndKeyPair{
		X509Cert: cert,
		CertBlock: &pem.Block{
			Type:  "CERTIFICATE",
			Bytes: certRaw,
		},
		PrivateKey: newCertKey,
		PrivateKeyBlock: &pem.Block{
			Type:  "ECDSA PRIVATE KEY",
			Bytes: privateKeyRaw,
		},
	}
}

type certAndKeyPair struct {
	X509Cert        *x509.Certificate
	CertBlock       *pem.Block
	PrivateKey      crypto.Signer
	PrivateKeyBlock *pem.Block
}

func x509TemplateWithExpirationOrFail(expiresAt time.Time, t *log.Logger) *x509.Certificate {
	serialNumberLimit := new(big.Int).Lsh(big.NewInt(1), 128)
	serialNumber, err := rand.Int(rand.Reader, serialNumberLimit)
	if err != nil {
		t.Fatalf("failed to generate serial number - %s", err.Error())
	}

	return &x509.Certificate{
		SerialNumber: serialNumber,
		NotBefore:    time.Now(),
		NotAfter:     expiresAt,
	}
}
